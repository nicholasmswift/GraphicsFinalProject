{"version":3,"sources":["_temp/SubdivisionModifier.js"],"names":[],"mappings":"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","file":"SubdivisionModifier.js","sourcesContent":["/*\r\n *\t@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog\r\n *\r\n *\tSubdivision Geometry Modifier\r\n *\t\tusing Loop Subdivision Scheme\r\n *\r\n *\tReferences:\r\n *\t\thttp://graphics.stanford.edu/~mdfisher/subdivision.html\r\n *\t\thttp://www.holmes3d.net/graphics/subdivision/\r\n *\t\thttp://www.cs.rutgers.edu/~decarlo/readings/subdiv-sg00c.pdf\r\n *\r\n *\tKnown Issues:\r\n *\t\t- currently doesn't handle UVs\r\n *\t\t- currently doesn't handle \"Sharp Edges\"\r\n *\r\n */\r\n\r\nTHREE.SubdivisionModifier = function ( subdivisions ) {\r\n\tthis.subdivisions = ( subdivisions === undefined ) ? 1 : subdivisions;\r\n};\r\n\r\n// Applies the \"modify\" pattern\r\nTHREE.SubdivisionModifier.prototype.modify = function ( geometry ) {\r\n\r\n\tvar repeats = this.subdivisions;\r\n\r\n\twhile ( repeats -- > 0 ) {\r\n\r\n\t\tthis.smooth( geometry );\r\n\r\n\t}\r\n\r\n\tdelete geometry.__tmpVertices;\r\n\r\n\tgeometry.computeFaceNormals();\r\n\tgeometry.computeVertexNormals();\r\n\r\n};\r\n\r\n( function() {\r\n\r\n\t// Some constants\r\n\tvar WARNINGS = ! true; // Set to true for development\r\n\tvar ABC = [ 'a', 'b', 'c' ];\r\n\r\n\r\n\tfunction getEdge( a, b, map ) {\r\n\r\n\t\tvar vertexIndexA = Math.min( a, b );\r\n\t\tvar vertexIndexB = Math.max( a, b );\r\n\r\n\t\tvar key = vertexIndexA + \"_\" + vertexIndexB;\r\n\r\n\t\treturn map[ key ];\r\n\r\n\t}\r\n\r\n\r\n\tfunction processEdge( a, b, vertices, map, face, metaVertices ) {\r\n\r\n\t\tvar vertexIndexA = Math.min( a, b );\r\n\t\tvar vertexIndexB = Math.max( a, b );\r\n\r\n\t\tvar key = vertexIndexA + \"_\" + vertexIndexB;\r\n\r\n\t\tvar edge;\r\n\r\n\t\tif ( key in map ) {\r\n\r\n\t\t\tedge = map[ key ];\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar vertexA = vertices[ vertexIndexA ];\r\n\t\t\tvar vertexB = vertices[ vertexIndexB ];\r\n\r\n\t\t\tedge = {\r\n\r\n\t\t\t\ta: vertexA, // pointer reference\r\n\t\t\t\tb: vertexB,\r\n\t\t\t\tnewEdge: null,\r\n\t\t\t\t// aIndex: a, // numbered reference\r\n\t\t\t\t// bIndex: b,\r\n\t\t\t\tfaces: [] // pointers to face\r\n\r\n\t\t\t};\r\n\r\n\t\t\tmap[ key ] = edge;\r\n\r\n\t\t}\r\n\r\n\t\tedge.faces.push( face );\r\n\r\n\t\tmetaVertices[ a ].edges.push( edge );\r\n\t\tmetaVertices[ b ].edges.push( edge );\r\n\r\n\r\n\t}\r\n\r\n\tfunction generateLookups( vertices, faces, metaVertices, edges ) {\r\n\r\n\t\tvar i, il, face, edge;\r\n\r\n\t\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tmetaVertices[ i ] = { edges: [] };\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = 0, il = faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = faces[ i ];\r\n\r\n\t\t\tprocessEdge( face.a, face.b, vertices, edges, face, metaVertices );\r\n\t\t\tprocessEdge( face.b, face.c, vertices, edges, face, metaVertices );\r\n\t\t\tprocessEdge( face.c, face.a, vertices, edges, face, metaVertices );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction newFace( newFaces, a, b, c ) {\r\n\r\n\t\tnewFaces.push( new THREE.Face3( a, b, c ) );\r\n\r\n\t}\r\n\r\n\r\n\t/////////////////////////////\r\n\r\n\t// Performs one iteration of Subdivision\r\n\tTHREE.SubdivisionModifier.prototype.smooth = function ( geometry ) {\r\n\r\n\t\tvar tmp = new THREE.Vector3();\r\n\r\n\t\tvar oldVertices, oldFaces;\r\n\t\tvar newVertices, newFaces; // newUVs = [];\r\n\r\n\t\tvar n, l, i, il, j, k;\r\n\t\tvar metaVertices, sourceEdges;\r\n\r\n\t\t// new stuff.\r\n\t\tvar sourceEdges, newEdgeVertices, newSourceVertices;\r\n\r\n\t\toldVertices = geometry.vertices; // { x, y, z}\r\n\t\toldFaces = geometry.faces; // { a: oldVertex1, b: oldVertex2, c: oldVertex3 }\r\n\r\n\t\t/******************************************************\r\n\t\t *\r\n\t\t * Step 0: Preprocess Geometry to Generate edges Lookup\r\n\t\t *\r\n\t\t *******************************************************/\r\n\r\n\t\tmetaVertices = new Array( oldVertices.length );\r\n\t\tsourceEdges = {}; // Edge => { oldVertex1, oldVertex2, faces[]  }\r\n\r\n\t\tgenerateLookups( oldVertices, oldFaces, metaVertices, sourceEdges );\r\n\r\n\r\n\t\t/******************************************************\r\n\t\t *\r\n\t\t *\tStep 1.\r\n\t\t *\tFor each edge, create a new Edge Vertex,\r\n\t\t *\tthen position it.\r\n\t\t *\r\n\t\t *******************************************************/\r\n\r\n\t\tnewEdgeVertices = [];\r\n\t\tvar other, currentEdge, newEdge, face;\r\n\t\tvar edgeVertexWeight, adjacentVertexWeight, connectedFaces;\r\n\r\n\t\tfor ( i in sourceEdges ) {\r\n\r\n\t\t\tcurrentEdge = sourceEdges[ i ];\r\n\t\t\tnewEdge = new THREE.Vector3();\r\n\r\n\t\t\tedgeVertexWeight = 3 / 8;\r\n\t\t\tadjacentVertexWeight = 1 / 8;\r\n\r\n\t\t\tconnectedFaces = currentEdge.faces.length;\r\n\r\n\t\t\t// check how many linked faces. 2 should be correct.\r\n\t\t\tif ( connectedFaces != 2 ) {\r\n\r\n\t\t\t\t// if length is not 2, handle condition\r\n\t\t\t\tedgeVertexWeight = 0.5;\r\n\t\t\t\tadjacentVertexWeight = 0;\r\n\r\n\t\t\t\tif ( connectedFaces != 1 ) {\r\n\r\n\t\t\t\t\tif ( WARNINGS ) console.warn( 'Subdivision Modifier: Number of connected faces != 2, is: ', connectedFaces, currentEdge );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnewEdge.addVectors( currentEdge.a, currentEdge.b ).multiplyScalar( edgeVertexWeight );\r\n\r\n\t\t\ttmp.set( 0, 0, 0 );\r\n\r\n\t\t\tfor ( j = 0; j < connectedFaces; j ++ ) {\r\n\r\n\t\t\t\tface = currentEdge.faces[ j ];\r\n\r\n\t\t\t\tfor ( k = 0; k < 3; k ++ ) {\r\n\r\n\t\t\t\t\tother = oldVertices[ face[ ABC[ k ] ] ];\r\n\t\t\t\t\tif ( other !== currentEdge.a && other !== currentEdge.b ) break;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttmp.add( other );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttmp.multiplyScalar( adjacentVertexWeight );\r\n\t\t\tnewEdge.add( tmp );\r\n\r\n\t\t\tcurrentEdge.newEdge = newEdgeVertices.length;\r\n\t\t\tnewEdgeVertices.push( newEdge );\r\n\r\n\t\t\t// console.log(currentEdge, newEdge);\r\n\r\n\t\t}\r\n\r\n\t\t/******************************************************\r\n\t\t *\r\n\t\t *\tStep 2.\r\n\t\t *\tReposition each source vertices.\r\n\t\t *\r\n\t\t *******************************************************/\r\n\r\n\t\tvar beta, sourceVertexWeight, connectingVertexWeight;\r\n\t\tvar connectingEdge, connectingEdges, oldVertex, newSourceVertex;\r\n\t\tnewSourceVertices = [];\r\n\r\n\t\tfor ( i = 0, il = oldVertices.length; i < il; i ++ ) {\r\n\r\n\t\t\toldVertex = oldVertices[ i ];\r\n\r\n\t\t\t// find all connecting edges (using lookupTable)\r\n\t\t\tconnectingEdges = metaVertices[ i ].edges;\r\n\t\t\tn = connectingEdges.length;\r\n\t\t\tbeta;\r\n\r\n\t\t\tif ( n == 3 ) {\r\n\r\n\t\t\t\tbeta = 3 / 16;\r\n\r\n\t\t\t} else if ( n > 3 ) {\r\n\r\n\t\t\t\tbeta = 3 / ( 8 * n ); // Warren's modified formula\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Loop's original beta formula\r\n\t\t\t// beta = 1 / n * ( 5/8 - Math.pow( 3/8 + 1/4 * Math.cos( 2 * Math. PI / n ), 2) );\r\n\r\n\t\t\tsourceVertexWeight = 1 - n * beta;\r\n\t\t\tconnectingVertexWeight = beta;\r\n\r\n\t\t\tif ( n <= 2 ) {\r\n\r\n\t\t\t\t// crease and boundary rules\r\n\t\t\t\t// console.warn('crease and boundary rules');\r\n\r\n\t\t\t\tif ( n == 2 ) {\r\n\r\n\t\t\t\t\tif ( WARNINGS ) console.warn( '2 connecting edges', connectingEdges );\r\n\t\t\t\t\tsourceVertexWeight = 3 / 4;\r\n\t\t\t\t\tconnectingVertexWeight = 1 / 8;\r\n\r\n\t\t\t\t\t// sourceVertexWeight = 1;\r\n\t\t\t\t\t// connectingVertexWeight = 0;\r\n\r\n\t\t\t\t} else if ( n == 1 ) {\r\n\r\n\t\t\t\t\tif ( WARNINGS ) console.warn( 'only 1 connecting edge' );\r\n\r\n\t\t\t\t} else if ( n == 0 ) {\r\n\r\n\t\t\t\t\tif ( WARNINGS ) console.warn( '0 connecting edges' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnewSourceVertex = oldVertex.clone().multiplyScalar( sourceVertexWeight );\r\n\r\n\t\t\ttmp.set( 0, 0, 0 );\r\n\r\n\t\t\tfor ( j = 0; j < n; j ++ ) {\r\n\r\n\t\t\t\tconnectingEdge = connectingEdges[ j ];\r\n\t\t\t\tother = connectingEdge.a !== oldVertex ? connectingEdge.a : connectingEdge.b;\r\n\t\t\t\ttmp.add( other );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttmp.multiplyScalar( connectingVertexWeight );\r\n\t\t\tnewSourceVertex.add( tmp );\r\n\r\n\t\t\tnewSourceVertices.push( newSourceVertex );\r\n\r\n\t\t}\r\n\r\n\r\n\t\t/******************************************************\r\n\t\t *\r\n\t\t *\tStep 3.\r\n\t\t *\tGenerate Faces between source vertecies\r\n\t\t *\tand edge vertices.\r\n\t\t *\r\n\t\t *******************************************************/\r\n\r\n\t\tnewVertices = newSourceVertices.concat( newEdgeVertices );\r\n\t\tvar sl = newSourceVertices.length, edge1, edge2, edge3;\r\n\t\tnewFaces = [];\r\n\r\n\t\tfor ( i = 0, il = oldFaces.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = oldFaces[ i ];\r\n\r\n\t\t\t// find the 3 new edges vertex of each old face\r\n\r\n\t\t\tedge1 = getEdge( face.a, face.b, sourceEdges ).newEdge + sl;\r\n\t\t\tedge2 = getEdge( face.b, face.c, sourceEdges ).newEdge + sl;\r\n\t\t\tedge3 = getEdge( face.c, face.a, sourceEdges ).newEdge + sl;\r\n\r\n\t\t\t// create 4 faces.\r\n\r\n\t\t\tnewFace( newFaces, edge1, edge2, edge3 );\r\n\t\t\tnewFace( newFaces, face.a, edge1, edge3 );\r\n\t\t\tnewFace( newFaces, face.b, edge2, edge1 );\r\n\t\t\tnewFace( newFaces, face.c, edge3, edge2 );\r\n\r\n\t\t}\r\n\r\n\t\t// Overwrite old arrays\r\n\t\tgeometry.vertices = newVertices;\r\n\t\tgeometry.faces = newFaces;\r\n\r\n\t\t// console.log('done');\r\n\r\n\t};\r\n\r\n\r\n} )();\r\n"]}