{"version":3,"sources":["physics/meshes/heightfieldMesh.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;;;;IAEa,e,WAAA,e;;;AACX,6BAAY,QAAZ,EAAsB,QAAtB,EAAyD;AAAA,YAAzB,MAAyB,yDAAhB,EAAgB;AAAA,YAAZ,IAAY;AAAA,YAAN,IAAM;AAAA;;AACvD,YAAM,aAAa,OAAO,OAA1B;AACA,YAAM,OAAO,WAAW,IAAX,IAAmB,OAAO,IAAvC;;AAFuD,qHAGjD,QAHiD,EAGvC,QAHuC,EAG7B,IAH6B;;AAKvD,iBAAS,kBAAT;;AAEA,YAAM,WAAW,oBAAoB,MAAM,cAA3C;AACA,YAAM,QAAQ,WAAW,SAAS,UAAT,CAAoB,QAApB,CAA6B,KAAxC,GAAgD,SAAS,QAAvE;;AAEA,YAAI,OAAO,WAAW,MAAM,MAAN,GAAe,CAA1B,GAA8B,MAAM,MAA/C;;AAEA,cAAK,QAAL,CAAc,IAAd,GAAqB,aAArB;AACA,cAAK,QAAL,CAAc,KAAd,GAAsB,SAAS,WAAT,CAAqB,GAArB,CAAyB,CAAzB,GAA6B,SAAS,WAAT,CAAqB,GAArB,CAAyB,CAA5E;AACA,cAAK,QAAL,CAAc,KAAd,GAAsB,SAAS,WAAT,CAAqB,GAArB,CAAyB,CAAzB,GAA6B,SAAS,WAAT,CAAqB,GAArB,CAAyB,CAA5E;AACA,cAAK,QAAL,CAAc,IAAd,GAAsB,OAAO,IAAP,KAAgB,WAAjB,GAAgC,KAAK,IAAL,CAAU,IAAV,CAAhC,GAAkD,OAAO,CAA9E;AACA,cAAK,QAAL,CAAc,IAAd,GAAsB,OAAO,IAAP,KAAgB,WAAjB,GAAgC,KAAK,IAAL,CAAU,IAAV,CAAhC,GAAkD,OAAO,CAA9E;;AAEA;AACA,cAAK,QAAL,CAAc,YAAd,GAA6B,KAAK,GAAL,CAAS,SAAS,WAAT,CAAqB,GAArB,CAAyB,CAAlC,EAAqC,KAAK,GAAL,CAAS,SAAS,WAAT,CAAqB,GAArB,CAAyB,CAAlC,CAArC,CAA7B;;AAEA,YAAM,SAAS,IAAI,YAAJ,CAAiB,IAAjB,CAAf;AAAA,YACE,OAAO,MAAK,QAAL,CAAc,IADvB;AAAA,YAEE,OAAO,MAAK,QAAL,CAAc,IAFvB;;AAIA,eAAO,MAAP,EAAe;AACb,gBAAM,OAAO,OAAO,IAAP,GAAe,CAAC,OAAO,KAAK,KAAL,CAAY,OAAO,IAAR,GAAkB,OAAO,IAAR,GAAgB,IAA5C,CAAP,GAA4D,CAA7D,IAAkE,IAA9F;;AAEA,gBAAI,QAAJ,EAAc,OAAO,IAAP,IAAe,MAAM,OAAO,CAAP,GAAW,CAAjB,CAAf,CAAd,KACK,OAAO,IAAP,IAAe,MAAM,IAAN,EAAY,CAA3B;AACN;;AAED,cAAK,QAAL,CAAc,MAAd,GAAuB,MAAvB;;AAEA,cAAK,QAAL,CAAc,MAAd,GAAuB;AACrB,sBAAU,WAAW,QADA;AAErB,yBAAa,WAAW,WAFH;AAGrB,qBAAS,WAAW,OAHC;AAIrB,oBAAQ,WAAW;AAJE,SAAvB;;AAOA,cAAK,QAAL,CAAc,IAAd,GAAqB,IAArB;AAzCuD;AA0CxD","file":"heightfieldMesh.js","sourcesContent":["import {Mesh} from '../core/mesh';\r\n\r\nexport class HeightfieldMesh extends Mesh {\r\n  constructor(geometry, material, params = {}, xdiv, ydiv) {\r\n    const physParams = params.physics;\r\n    const mass = physParams.mass || params.mass;\r\n    super(geometry, material, mass);\r\n\r\n    geometry.computeBoundingBox();\r\n\r\n    const isBuffer = geometry instanceof THREE.BufferGeometry;\r\n    const verts = isBuffer ? geometry.attributes.position.array : geometry.vertices;\r\n\r\n    let size = isBuffer ? verts.length / 3 : verts.length;\r\n\r\n    this._physijs.type = 'heightfield';\r\n    this._physijs.xsize = geometry.boundingBox.max.x - geometry.boundingBox.min.x;\r\n    this._physijs.ysize = geometry.boundingBox.max.y - geometry.boundingBox.min.y;\r\n    this._physijs.xpts = (typeof xdiv === 'undefined') ? Math.sqrt(size) : xdiv + 1;\r\n    this._physijs.ypts = (typeof ydiv === 'undefined') ? Math.sqrt(size) : ydiv + 1;\r\n\r\n    // note - this assumes our plane geometry is square, unless we pass in specific xdiv and ydiv\r\n    this._physijs.absMaxHeight = Math.max(geometry.boundingBox.max.z, Math.abs(geometry.boundingBox.min.z));\r\n\r\n    const points = new Float32Array(size),\r\n      xpts = this._physijs.xpts,\r\n      ypts = this._physijs.ypts;\r\n\r\n    while (size--) {\r\n      const vNum = size % xpts + ((ypts - Math.round((size / xpts) - ((size % xpts) / xpts)) - 1) * ypts);\r\n\r\n      if (isBuffer) points[size] = verts[vNum * 3 + 2];\r\n      else points[size] = verts[vNum].z;\r\n    }\r\n\r\n    this._physijs.points = points;\r\n\r\n    this._physijs.params = {\r\n      friction: physParams.friction,\r\n      restitution: physParams.restitution,\r\n      damping: physParams.damping,\r\n      margin: physParams.margin\r\n    };\r\n\r\n    this._physijs.mass = mass;\r\n  }\r\n}\r\n"]}