{"version":3,"sources":["physics/meshes/softMesh.js"],"names":[],"mappings":"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","file":"softMesh.js","sourcesContent":["import {Mesh} from '../core/mesh';\r\n\r\nexport class SoftMesh extends Mesh {\r\n  constructor(geometry, material, params = {}) {\r\n    const physParams = params.physics;\r\n    const mass = physParams.mass || params.mass;\r\n    const tempGeometry = geometry.clone();\r\n\r\n    if (!(geometry instanceof THREE.BufferGeometry)) // Converts to BufferGeometry.\r\n      geometry = new THREE.BufferGeometry().fromGeometry(geometry);\r\n\r\n    super(geometry, material, mass);\r\n\r\n    tempGeometry.mergeVertices();\r\n    const idxGeometry = this.createIndexedBufferGeometryFromGeometry(tempGeometry);\r\n    this.tempGeometry = tempGeometry;\r\n\r\n    const aVertices = idxGeometry.attributes.position.array;\r\n    const aIndices = idxGeometry.index.array;\r\n    const aIdxAssoc = [];\r\n    const vertices = geometry.attributes.position.array;\r\n\r\n    const numIdxVertices = aVertices.length / 3;\r\n    const numVertices = vertices.length / 3;\r\n\r\n    for (let i = 0; i < numIdxVertices; i++) {\r\n      const association = [];\r\n      aIdxAssoc.push(association);\r\n\r\n      const i3 = i * 3;\r\n\r\n      for (let j = 0; j < numVertices; j++) {\r\n        const j3 = j * 3;\r\n\r\n        if (this.isEqual(aVertices[i3], aVertices[i3 + 1], aVertices[i3 + 2], vertices[j3], vertices[j3 + 1], vertices[j3 + 2]))\r\n          association.push(j3);\r\n      }\r\n    }\r\n\r\n    this._physijs.type = 'softTrimesh';\r\n    this._physijs.aVertices = aVertices;\r\n    this._physijs.aIndices = aIndices;\r\n    this._physijs.aIdxAssoc = aIdxAssoc;\r\n\r\n\r\n    this._physijs.params = {\r\n      friction: physParams.friction,\r\n      damping: physParams.damping,\r\n      pressure: physParams.pressure,\r\n      margin: physParams.margin,\r\n      klst: physParams.klst,\r\n      kast: physParams.kast,\r\n      kvst: physParams.kvst,\r\n      drag: physParams.drag,\r\n      lift: physParams.lift,\r\n      anchorHardness: physParams.anchorHardness,\r\n      rigidHardness: physParams.rigidHardness,\r\n    };\r\n\r\n    this._physijs.mass = mass;\r\n  }\r\n\r\n  createIndexedBufferGeometryFromGeometry(geometry) {\r\n    const numVertices = geometry.vertices.length;\r\n    const numFaces = geometry.faces.length;\r\n    const bufferGeom = new THREE.BufferGeometry();\r\n    const vertices = new Float32Array(numVertices * 3);\r\n    const indices = new (numFaces * 3 > 65535 ? Uint32Array : Uint16Array)(numFaces * 3);\r\n\r\n    for (let i = 0; i < numVertices; i++) {\r\n      const p = geometry.vertices[i];\r\n      const i3 = i * 3;\r\n\r\n      vertices[i3] = p.x;\r\n      vertices[i3 + 1] = p.y;\r\n      vertices[i3 + 2] = p.z;\r\n    }\r\n\r\n    for (let i = 0; i < numFaces; i++) {\r\n      const f = geometry.faces[i];\r\n      const i3 = i * 3;\r\n\r\n      indices[i3] = f.a;\r\n      indices[i3 + 1] = f.b;\r\n      indices[i3 + 2] = f.c;\r\n    }\r\n\r\n    bufferGeom.setIndex(new THREE.BufferAttribute(indices, 1));\r\n    bufferGeom.addAttribute('position', new THREE.BufferAttribute(vertices, 3));\r\n\r\n    return bufferGeom;\r\n  }\r\n\r\n  isEqual(x1, y1, z1, x2, y2, z2) {\r\n    const delta = 0.000001;\r\n\r\n    return Math.abs(x2 - x1) < delta\r\n      && Math.abs(y2 - y1) < delta\r\n      && Math.abs(z2 - z1) < delta;\r\n  }\r\n\r\n  appendAnchor(world, object, node, influence, collisionBetweenLinkedBodies = true) {\r\n    const o1 = this._physijs.id;\r\n    const o2 = object._physijs.id;\r\n\r\n    world.execute('appendAnchor', {\r\n      obj: o1,\r\n      obj2: o2,\r\n      node,\r\n      influence,\r\n      collisionBetweenLinkedBodies\r\n    });\r\n  }\r\n}\r\n"]}